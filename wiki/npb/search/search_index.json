{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This user guide provides instructions on how to design, build and run  the network protocols bridges (NPB) and its digital twin (DT).  Two use cases 01 &amp; 02 demonstrates simulated applications of the NPB. </p> <p> Note: This document is intended to use on Linux  machines.  </p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ol> <li> <p>Development Environment Setup </p> <p>Instructions on settings up Papyrus4Manufacturing. </p> </li> <li> <p>AAS Model design </p> <p>Instructions on designing an AAS model for NPB and NPB DT.    </p> </li> <li> <p>Software NPB generation </p> <p>Instructions on generating and configuring NPB.    </p> </li> <li> <p>NPB Digital Twin generation </p> <p>Instructions on generating and configuring AAS DT of NPB.   </p> </li> <li> <p>Use case 01: Product Assembly Line </p> <p>Production Assembly Line use case description and deployment steps.    </p> </li> <li> <p>Use case 02: Waterfall </p> <p>Waterfall use case description and deployment steps.   </p> </li> </ol>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>This document and its related resources are developed within the project  TARGET-X : ROS6GBridge. The TARGET-X project  has received funding from the  Smart Networks and Services Joint Undertaking (SNS JU) under the  European Union's Horizon Europe research and innovation program under  Grant Agreement No 101096614. </p>"},{"location":"design/","title":"AAS Model Design","text":"<p>Asset Administration Shell (AAS) is an industrial standard developed by  IDTA. The AAS model is likely the UML Class diagram with the concepts from the AAS standard.  This section focus on using Papyrus4Manufacturing to design an AAS model to  generate NPB and NPB DT.   </p>"},{"location":"design/#step-by-step-guide","title":"Step-by-Step Guide","text":"<p>This section presents three basic steps to design an AAS Model  for NPB and NPB DT. You can find the detail description about how to design an AAS model using the cheet sheets of Papyrus4Manufacturing.  </p>"},{"location":"design/#step-1-create-papyrus-project","title":"Step 1: Create Papyrus Project","text":"<p>Open Papyrus4Manufacturing. In the menu bar,  go to File &gt; New &gt; Project... &gt; Papyrus &gt; Papyrus Project,  then click Next. In the new appeared window,  check AAS Modeling Language, then click Next.  Input the required information, including the Project name and location,  then click Finish.  In the Project Explorer window, a new folder is generated with related  files di, notation, and uml. </p>               Figure 1. Project is created and shown in the Project Explorer window"},{"location":"design/#step-2-design-an-aas-model-for-npb","title":"Step 2: Design an AAS model for NPB","text":"<p>In the Project Explorer window, double click on the Papyrus icon under the  new created folder. Next, it is necessary to create an asset (means NPB),  its AAS (means NPB DT), and its two AAS submodels Interfaces  and Routing.   </p>"},{"location":"design/#a-design-asset-npb","title":"A. Design Asset (NPB)","text":"<p>In the Model Explorer window, the model folder appears. Right click at the  folder, go to New Package child &gt; Asset.  In the Properties window, you need to input the information of the asset.  The following fields are fundamental: - Asset: the name of the asset. Choose a name, such as BrxFPGA - Kind: the type of the model element. Choose Instance.  - Identification: the identifier of the asset. Click the plus button,  choose idType as Custom, then input an id. - Endpoint: the endpoint that the NPB expose to its NPB DT to connect.  Click the plus button, input the information about the address  and name of the endpoint.  </p> <p> Note: The current version of NPB only supports the  WebSocket endpoint.  </p>                                        Figure 2. Endpoint and Identifcation fields of the asset BrxFPGA"},{"location":"design/#b-design-aas-npb-dt","title":"B. Design AAS (NPB DT)","text":"<p>In the Model Explorer window. Right click at Asset,  go to New Asset child &gt; AAS. In the Properties window, you need  to input the information of the AAS.  In the Properties window, you need to input the information of the AAS.  The following fields are fundamental: - Name: the name of the AAS. Choose a name, such as BrxFPGA.  - Identification: the identifier of the AAS. Click the plus button,  choose idType as Custom, then input an id. - Endpoint: the endpoint that the NPB DT expose to external application.  Click the plus button, input the information about the address  and name of the endpoint.  </p> <p> Note: The name of asset and its AAS DT can be the same and  should have at least three letters.  </p>"},{"location":"design/#c-design-interfaces-and-routing-submodels","title":"C. Design Interfaces and Routing submodels","text":"<p>The two submodels Interfaces and Routing are fundamental and required  by the NPB. You can add other submodels to the AAS model.  </p> <p>In the Model Explorer window. Right click at AAS,  go to New AAS child &gt; Submodel to create one submodel.  Repeat the step to create the second one.  In the Properties window, you need to input the information required by each submodel.  The following fields are fundamental: - Name: the name of the submodel. Input Interfaces for the  first submodel, and Routing for the second submodel.  - Kind: the type of the submodel. Choose Instance.  - Identification: the identifier of the AAS. Click the plus button,  choose idType as Custom, then input an id.  </p> <p> Note: The submodel must be Interfaces and  Routing.  If written incorrectly, it will not function properly. </p> <p>In the Interfaces submodel, add properties related to the network interfaces that your NPB supports. Right click at Interfaces,  go to New Submodel child &gt; Property. Likewise, in the Routing submodel, add properties related to  the routing nodes that your NPB supports. You must use the Properties window to specify each property.  The following fields are fundamental for a property: - Name: the name of the property.  - Is dynamic: the value of the property is changable or not. Choose true.  - Endpoint: the endpoint related to the property. Choose the endpoint of the asset.  - Kind: the type of the submodel. Choose Instance.  - Type: the data type of the value of the property. Choose Boolean.    </p>                                        Figure 3. Submodels Interfaces and Routing with their properties  <ul> Note: <li> The property of Interfaces can be ros2,  modbustcp, ethernetip,  uafx, or canopen.  If written incorrectly, it will not function properly </li> <li> The property of Routing must follow the format  brx_[A]_[B]_[C]. In which, A is device id, B is group id, and C is node id.  If using the wrong format, it will not function properly </li> </ul>"},{"location":"design/#step-3-activate-the-npb-generation-feature","title":"Step 3: Activate the NPB generation feature","text":"<p>In the Project Explorer window, right click on di file,  go to Open With &gt; Text Editor.  In the appeared editor window, add <code>featureId=\"ceatmp1015750572\"</code> right before <code>/&gt;</code> in the second line. </p>                                            Figure 4. Information about featureId in di file"},{"location":"design/#helpful-tips","title":"Helpful Tips","text":"<p>This section presents some useful tips to design AAS model for NPB and NPB DT. </p>"},{"location":"design/#aas-model-validation","title":"AAS Model Validation","text":"<p>The validation tool is intergrated into Papyrus4Manufacturing.  In the Model Explorer window, right click at the model element needed to be valided, go to Validation &gt; Validation Model.  The result of the validation will be shown on the Model Validation window.  </p>                                            Figure 5. Validation window details the error of an AAS model design"},{"location":"design/#viewing-model-design-with-the-class-diagram-designer","title":"Viewing model design with the Class Diagram Designer","text":"<p>An AAS model design can be viewed with the Class diagram. In the Model Explorer window. Right click at the folder Assets,  go to New Diagram &gt; AAS Design Diagram.  Double click on the diagram to open diagram editor.  You can drag-and-drop the element from the Model Explorer window into this  editor. Use the pallette to add other elements if necessary. </p>                                            Figure 6. AAS model viewed as a Class diagram"},{"location":"genaas/","title":"Network Protocols Bridge Digital Twin Generation","text":"<p>Network Protocols Bridge (NPB) Digital Twin (DT) is a software component  working as a Software-Defined Networking controller that can monitor and  configure the NPB at runtime. Technically, a NPB DT is an AAS DT of the NPB.  The generation of NPB DT from the AAS model is integrated into the  Papyrus4Manufacturing. </p>"},{"location":"genaas/#step-by-step-guide","title":"Step-by-Step Guide","text":"<p>This section presents three basic steps to generate NPB DT.</p>"},{"location":"genaas/#step-1-generate-aas-dt-java-maven-project","title":"Step 1: Generate AAS DT Java Maven project","text":"<p>In the Model Explorer window, right click at the AAS,  go to AAS &gt; Generate Asset Administration Shell BaSyx Code (AAS).  If the AAS model design is correct, then a new generate code folder will  appear in the Project Explorer window and it will show no error  (no red star on the project icon). </p> <p>If there is no new generated folder or a new project is generated with  a red star, you should recheck the AAS model design and re-generate it. </p>               Figure 1. Successful new generated Java Maven project for AAS DT       <p> Note: The files generated can be different depended on the  featureId.   </p>"},{"location":"genaas/#step-2-modifying-java-codes","title":"Step 2: Modifying Java Codes","text":"<p>In general, the generated Java code is ready to use,  but you can modify the generated Java codes for further customization.  This step requires basic knowledge on Java programming. </p> <p>In the Model Explorer window, browse the folder src/main/java.  This folder includes all of the Java source code related to the AAS DT.  </p> <p> Note: Your new added codes can be overried when you re-generate  the AAS project. So you should be careful.  </p>"},{"location":"genaas/#usage","title":"Usage","text":"<p>You can run the NPB DT on the Papyrus4Manufacturing environment:  In the Project Explorer, right click at  the AASServer.launch file,  go to Run As &gt; AASServer.</p> <p>If the NPB DT boots correctly, it will connect to the NPB and expose a AAS standard HTTP interface to external applications.  The interface listens to the endpoint defined in the design. </p>         Figure 2. HTTP external interface of a sucessful run NPB DT      <p> Note: The NPB must be running before launching the NPB DT.  If not, an error will occur.  </p> <p>There are two methods to interact with the NPB DT.  First is to use the HTTP REST API as other AAS DTs  generated by Papyrus4Manufacturing. To check the API, you can open the README.md file generated  in the generated project. </p> <p>The second method is to use the Graphic User Interface (GUI) integrated into the NPB DT. Open a web browser, and enter the NPB DT endpoint with the path <code>/p4m/gui</code>. This GUI has a monitoring board that observes properties and operations of the NPB DT.  A command chat box allowing users to input the command to  interact with the NPB DT.  Some valid commands are log, read, write, call, and reload.  </p>            Figure 3. Runing the command \"log\" on the GUI of NPB DT"},{"location":"genaas/#helpful-tips","title":"Helpful Tips","text":"<p>This section presents some useful tips to build and run NPB DT.</p>"},{"location":"genaas/#backup-code","title":"Backup code","text":"<p>Remember to backup your code to a new folder before re-generating the  project. A simple method is to copy and paste the the project in  Project Explorer. For the step: right click at the project folder,  press Ctrl + C, then press Ctrl + V. In the new appeared window,  change the name of new project then click Copy. </p> <p>Another way to backup code is to use git. Open your terminal and  navigate to your project. Using the following commands.  </p> <p>$ <code>git init</code> $ <code>git add .</code> $ <code>git commit -m \"SOME IMPORTANT MESSAGE\"</code> </p>"},{"location":"genaas/#interact-with-npb-dts-http-interface-using-postman","title":"Interact with NPB DT's HTTP interface using Postman","text":"<p>Postman is a good tool to create HTTP REST commands and interact with  the HTTP interface of the NPB DT.  To install and run the standalone version:  </p> <p>$ <code>wget https://dl.pstmn.io/download/latest/linux_64</code> $ <code>tar -xvzf postman-linux-x64.tar.gz</code> $ <code>./Postman/Postman</code> </p> <p>For more information, check the Postman's  tutorial.</p>"},{"location":"gennpb/","title":"Software Network Protocols Bridge Generation","text":"<p>Network Protocols Bridge (NPB) is a software component that can bridge  different industrial network protocols,  including Modbus TCP, OPC UA PubSub, EtherNet/IP Class 1,  ROS 2, and CANopen.  The generation of this software component from the AAS model is integrated  into the Papyrus4Manufacturing. </p>"},{"location":"gennpb/#step-by-step-guide","title":"Step-by-Step Guide","text":"<p>This section presents three basic steps to generate software NPB.</p>"},{"location":"gennpb/#step-1-generate-npb-java-maven-project","title":"Step 1: Generate NPB Java Maven project","text":"<p>In the Model Explorer window, right click at the AAS,  go to AAS &gt; Generate Network Protocols Bridge (NPB).  If the AAS model design is correct, then a new generate code folder will  appear in the Project Explorer window and it will show no error  (no red star on the project icon). </p> <p>If there is no new generated folder or a new project is generated with  a red star, you should recheck the AAS model design and re-generate it. </p>            Figure 1. Successful new generated Java Maven project for NPB       <p> Note: The files generated can be different depended on the  featureId.   </p>"},{"location":"gennpb/#step-2-build-the-npb-software","title":"Step 2: Build the NPB software","text":"<p>Two methods to build the NPB software.  First, in the Project Explorer window, right click at the pom.xml file,  go Maven &gt; Update Project....  In the new appeared window, check Force Update of Snapshots/Releases,  click OK.  Right click at the pom.xml again, go to Run As &gt; Maven Install. </p> <p>In the second, open a terminal. Run the following commands: </p> <p>$ <code>cd &lt;YOUR_PROJECT_WORKSPACE&gt;</code> $ <code>mvn clean install -U</code></p>          Figure 2. Successful build with the second method"},{"location":"gennpb/#usage","title":"Usage","text":"<p>You can run the NPB on the Papyrus4Manufacturing environment:  In the Project Explorer, right click at the project folder of the NPB,  go to Run As &gt; Java Application.</p> <p> Note: If an error related to root privileges occur due to the need of root access for some ports (e.g. default port 502 for Modbus TCP),  re-run Papyrus4Manufacturing with sudo.  </p> <p>Another method is to use Docker.  Search for the docker images generated by the build then run it with  adequate parameters.  We supports also a run.sh including the command the Docker with  pre-defined parameters in the generated NPB folder. </p> <p>If the NPB boots correctly, the console will show no error  and all network interfaces are raised properly. </p>         Figure 3. Successful run NPB"},{"location":"gennpb/#helpful-tips","title":"Helpful Tips","text":"<p>This section presents some useful tips to build and run NPB.</p>"},{"location":"gennpb/#devices-configuration","title":"Devices configuration","text":"<p>The EtherNet/IP device must work in adapter mode and be turned on before  connecting to the NPB.  In other words, the EtherNet/IP device needs to boot first,  then you can launch the NPB. You should get the parameters in the EDS associated to  the EtherNet/IP device to configure the application.properties  file of NPB.  This configuration requires knowledge on the EtherNet/IP.</p> <p>To test CANopen device, you can use a virtual can (vcan) interface and using a tunnel to translate CAN-Socket data messages. </p>"},{"location":"gennpb/#network-configuration","title":"Network configuration","text":"<p>To check the available network interfaces in your computer, you can use one  of following commands: </p> <p>$ <code>ifconfig</code> $ <code>ip address</code> </p> <p>To raise network interface vcan0 required by CANopen, you use the following  commands: </p> <p>$ <code>sudo modprobe vcan</code> $ <code>sudo ip link add dev vcan0 type vcan</code> $ <code>sudo ip link set vcan0 mtu 16</code> $ <code>sudo ip link set up vcan0</code> </p> <p>Some default values of network interfaces' configuration: - The default port of ModbusTCP is 502.  - The default port of OPC UA PubSub is 4801.  - The default port of EtherNet/IP is 2222 and 44818.  - The default ROS DOMAIN ID of ROS2 is 0.    </p>"},{"location":"setup/","title":"Environment Setup","text":"<p>Papyrus4Manufacturing provides an Intergrated Development Environment (IDE) to design and develop NPB and AAS DT of the NPB.  The following steps guide you to download and run the IDE on your computer. </p>"},{"location":"setup/#step-by-step-guide","title":"Step-by-Step Guide","text":"<p>Two basic steps to download and setup Papyrus4Manufacturing IDE. </p>"},{"location":"setup/#step-1-download-papyrus4manufacturing","title":"Step 1: Download Papyrus4Manufacturing","text":"<p>Open your web browser and navigate to the official  Papyrus4Manufacturing website. In the navigate bar of the website, go to  Downloads AAS Designer &gt; Nightly RCP section.  Click to download and save the file to the workspace in your computer. </p>                                            Figure 1. Download the Nightly RCP Papyrus4Manufacturing version"},{"location":"setup/#step-2-run-papyrus4manufacturing","title":"Step 2: Run Papyrus4Manufacturing","text":"<p>Extract the downloaded file (p4m_nightly_linux.tar.gz).  You can use the following command: </p> <p>$ <code>tar -xvzf p4m_nightly_linux.tar.gz</code></p> <p>After the extraction, you will have a new folder Papyrus4AAS.  Inside this folder, there are resources to run the Papyrus4Manufacturing IDE. Launch it with the following command:  </p> <p>$ <code>./Papyrus4AAS/Papyrus4Manufacturing</code></p> <p>For the first launch, you must choose a workspace to save your future Papyrus4Manufacturing projects. Browse you target folder,  check the box Use this as the default and do not ask again,  then click Launch.  You should walkthrough the cheet sheets in the Cheet Sheets window to  understand the basic steps to design AAS and deploy AAS DT. </p>                                            Figure 2. Cheet Sheets window in the GUI of Papyrus4Manufacturing"},{"location":"setup/#helpful-tips","title":"Helpful Tips","text":"<p>Some tools are helpful for the development. </p>"},{"location":"setup/#install-tm-terminal-on-papyrus4manufacturing","title":"Install TM Terminal on Papyrus4Manufacturing","text":"<p>Open Papyrus4Manufacturing. In the menu bar,  go to Help &gt; Install New Software. In the Work with field, input  the URL <code>https://download.eclipse.org/tools/cdt/releases/11.6/</code>, click Add. Wait for the list to populate. Check the box Terminal Features and Terminal SDK Features, click Next, then continue with  the on-screen instructions. After the installation is finished, you need to  restart Papyrus4Manufacturing. </p> <p>To open the TM Terminal: in the menu bar,  go to Window &gt; Show View &gt; Other... &gt; Terminal.  The terminal tray will appear. Using the shortcut key Ctrl + Shift + Alt + T to  open a new terminal. </p>                                            Figure 3. TM Terminal on Papyrus4Manufacturing"},{"location":"setup/#install-docker-on-linux","title":"Install Docker on Linux","text":"<p>Open a terminal. Install the docker version for linux using apt:   </p> <p>$ <code>sudo apt install docker.io</code> </p> <p> Note: The version docker-ce can be used instead. </p> <p>Check if docker is succesfully installed with the following command.  The expected result is the header row of an empty table with no  running docker containers.  </p> <p>$ <code>docker ps</code> </p> <p>Enable your user account to use Docker without needing root privileges:   </p> <p>$ <code>sudo groupadd docker</code>  $ <code>sudo usermod -aG docker $USER</code></p>"},{"location":"uc01/","title":"Use Case 01: Product Assembly Line","text":"<p>Product Assembly Line (PAL) is a use case deployed at the testbed LocalSEA  in CEA List. The use case aims to test the bridge solution developed  in ROS6GBridge in a physical simulation of the industrial environment.  </p>"},{"location":"uc01/#description","title":"Description","text":"<p>PAL use case simulates a factory plan's segment with two workstations.  In the first workstation, a robot picks a part from a parts tray  and places it on a carrier. The carrier transport the object to the second workstation, where a worker will pick the object and assembles  it with different type of part. The worker clicks a button to notify that the object is already picked.  The number of sucessful objects will be calculated by a counter. </p>                                            Figure 1. Illustration of a pick and place scenario"},{"location":"uc01/#deployment-instructions","title":"Deployment Instructions","text":"<p>Five devices required by this use cases are:  (a) UR3e,  (b) TurtleBot3 Waffle Pi (T3WP),  (c) PLC Opta,  (d) Rapsberry Pi 2 (RPi2), and  (e) the board FPGA  designed and developed by Logiicdev. </p>                                            Figure 2. Devices used in the PAL use case        <p>Figure 3 illustrates the topology of the PAL use case. In detail, all  field-level devices communicate through the NPB bridge which is the FPGA board. The AAS DT of the NPB bridge plays a role of an Software-Defined Network (SDN) controller to monitor and control the NPB bridge. The AAS DT of the PAL  is an orchestrator which monitor and control the field-level devices  to deploy the PAL use case. </p>                                            Figure 3. Topology of the PAL use case       <p>Figure 4 illustrates the AAS information model used to generate bridge NPB and  its AAS DT. It shows that bridge NPB has four interfaces corresponding to  four protocols OPC UA FX, ROS 2, EtherNet/IP, and Modbus TCP. Each interface has one or several routing nodes.     </p>        Figure 4. The AAS information model of bridge NPB      <p>Figure 5 illustrates the BPMN diagram depicting the production process  of the PAL use case. The AAS DT of PAL has two threads: one monitors the  states of field-level devices, and the other orchestrates the devices for  production. The other components (UR3e, T3WP, RPi2, and Opta) wait for events  before proceeding with their operations.  </p>                                            Figure 5. BPMN of the production process of the PAL use case      <p>To deploy the PAL use case, users need to setup hardware devices and their  software. The software has several exact configurations associated to the  hardware devices as follows.   </p>"},{"location":"uc01/#step-1-network-setup","title":"Step 1: Network setup","text":"<p>Field-level devices can connect to the FPGA board via either an Ethernet cable  or WiFi. However, they all need to be on the 192.168.56.0/24 network.  In detail,    - UR3e: 192.168.56.16/24  - T3WP: 192.168.56.3/24  - RPi2: 192.168.56.18/24  - Opta: 192.168.56.12/24  - Brx:  192.168.56.11/24  otherwise, the software part may not work properly.  </p> <p>AAS PAL and AAS Brx can be either in the same network or in another network  and they need to be able to connect to Brx. </p>"},{"location":"uc01/#step-2-software-setup","title":"Step 2: Software setup","text":"<p>To support the deployment, many programs and Docker images are prepared in  ROS6GBridge UC01 kit. After downloading, users can extract it using the command:  </p> <p>$ <code>unzip UC01_kit.zip</code></p> <p>Inside the zip, there are different resources for different devices.   </p>"},{"location":"uc01/#a-ur3e","title":"a. UR3e","text":"<p>To install the program for UR3e, users need a running UR3e. The deployment  steps are as follows. </p> <p>Step 1: Extract the UR3e package and copy the inner files to an USB  </p> <p>$ <code>tar -zxvf ur3e_app.tar.gz</code> $ <code>sudo mount /dev/sda1 /mnt</code>  $ <code>cp ur3e_app/* /mnt</code> </p> <p>Step 2: Plug the USB onto the UR3e teach pendant. Load the files: - File &gt; Load Installation &gt; select ur3e.installation - File &gt; Load Program &gt; select ur3e_program.urp. The file ur3e.variables will be auto-loaded. </p> <p>Step 3: Run the program by clicking Play on the teach pendant.  </p>"},{"location":"uc01/#b-t3wp","title":"b. T3WP","text":"<p>To install the program for T3WP, users need a running T3WP with ROS2  middleware. The deployment steps are as follows.    </p> <p>Step 1: Extract the T3WP package and copy the inner file to an USB  </p> <p>$ <code>tar -zxvf t3wp_app.tar.gz</code> $ <code>sudo mount /dev/sda1 /mnt</code>  $ <code>cp t3wp_app/* /mnt</code> </p> <p>Step 2: On T3WP, enter the ROS2 workspace (e.g. ~/ros2ws,  then create a python ROS2 package  </p> <p>$ <code>cd ~/ros2ws</code> $ <code>ros2 pkg create palusecase --build-type ament_python --dependencies rclpy</code> </p> <p>Step 3: Plug the USB onto the Raspberry Pi of T3WP, copy the file, then  build it with colcon  </p> <p>$ <code>sudo mount /dev/sda1 /mnt</code>  $ <code>cp /mnt/t3wp_program ~/ros2ws/src/palusecase/palusecase/t3wp_program.py</code> $ <code>sudo chmod +x ~/ros2ws/src/palusecase/</code> $ <code>colcon build</code> </p> <p>Step 4: Run the program  </p> <p>$ <code>source install/setup.bash</code>  $ <code>ros2 run palusecase t3wp_program.py</code> </p>"},{"location":"uc01/#c-opta","title":"c. OPTA","text":"<p>To install the program for Opta, users need an Opta connect with the computer using a USB-C cable and a preinstalled  Arduino IDE.  The deployment steps are as follows.  </p> <p>Step 1: Extract the Opta package </p> <p>$ <code>tar -zxvf opta_app.tar.gz</code></p> <p>Step 2: Open Arduino, open the file: File &gt; Open... &gt; select <code>opta_program.ino</code>. Click Verify to verify the code, then click <code>Upload</code> to build and push the binary to the Opta.  </p> <p>Step 3: Opta only needs a power supply to run. However, to run the  program, users need to use a Modbus TCP client to set the target number to be produced first, then users click the USER button on the Opta to start the  program.  </p>"},{"location":"uc01/#d-rpi2","title":"d. RPi2","text":"<p>To install the program for RPi2, users need an Raspberry Pi with python3. The  deployment steps are as follows.   </p> <p>Step 1: Extract the RPi2 package and copy the inner file to an USB  </p> <p>$ <code>tar -zxvf rpi2_app.tar.gz</code> $ <code>sudo mount /dev/sda1 /mnt</code>  $ <code>cp rpi2_app/* /mnt</code> </p> <p>Step 2: Plug the USB onto RPi2, copy the files to a workspace  (e.g. ~/rpi2ws) then run the program   </p> <p>$ <code>sudo mount /dev/sda1 /mnt</code>  $ <code>cp /mnt/* ~/rpi2ws/</code>  $ <code>sudo chmod +x ~/rpi2ws/rpi2_program</code>  $ <code>cd ~/rpi2ws &amp;&amp; ./rpi2_program</code> </p>"},{"location":"uc01/#e-brx","title":"e. Brx","text":"<p>The Brx is put in a Docker image for arm64. Users need a FPGA running Ubuntu  arm64 or a Raspberry Pi working as bridge. The deployment steps are as follows.  </p> <p>Step 1: Copy brx_app.tar.gz onto the arm64 device.  </p> <p>Step 2: Users need to load the docker image, then run it.  </p> <p>$ <code>docker load -i brx_app.tar.gz</code>  $ <code>docker run -it --net=host --rm npb_brx:0.3.arm64</code> </p>"},{"location":"uc01/#f-aas-brx","title":"f. AAS Brx","text":"<p>The AAS Brx is put in a Docker image. Users need to load, then run it.  </p> <p>$ <code>docker load -i aas_brx_app.tar.gz</code> $ <code>docker run -it --net=host --rm aas_brxfpga:0.1.0-SNAPSHOT</code> </p>"},{"location":"uc01/#g-aas-pal","title":"g. AAS PAL","text":"<p>The AAS PAL is put in a Docker image. Users need to load, then run it.   </p> <p>$ <code>docker load -i pal_app.tar.gz</code>  $ <code>docker run -it --net=host --rm aas_pal:0.1</code> </p>"},{"location":"uc02/","title":"Use Case 02: Waterfall","text":"<p>Waterfall is a educative use case with a simple concept and  easy to reproduce.  It was first deployed in the LocalSEA testbed of CEA List,  then its components was dockerized using Docker to be able to test  in other environments. </p>"},{"location":"uc02/#description","title":"Description","text":"<p>Given a waterfall consisted of multiple stairs.  When pouring the water into a stair, the water will go down  stair-by-stair until the final one.  The use case mimic the mechanism of the waterfall.  Figure 1 illustrates this concept. </p>                                            Figure 1. Illustration of the waterfall concept       <p>There are five software components using five network protocols:  CANopen, Modbus TCP, OPC UA FX, ROS 2, and EtherNet/IP Class 1,  represent five stairs of the waterfall.  When a trigger send a message to a stair, it will trigger its  lower stair by sending a message to this lower one.  For example, when the stair OPC UA FX is triggered, it will trigger  the stair ROS 2; then, the stair ROS 2 will trigger the stair EtherNet/IP.  </p>"},{"location":"uc02/#deployment-instructions","title":"Deployment Instructions","text":"<p>Figure 2 shows the topology of the waterfall use case.  There are seven components: the NPB, five components for five stair  applications using the five protocols, and a component running as  the trigger. The trigger and the five stairs connect to the NPB.  All components are containerized into Docker images.  To ease the deployment, the Docker images for both amd64 and arm64 are prepared in ROS6GBridge UC02 kit. </p>                                            Figure 2. Topology of the waterfall use case      <p> Note: The official version of this use case supports only four  lastest stairs.  The CAN Open stair will be put as a  bonus.  </p> <p>This use case requires at least two devices, for example,  one computer (amd64) and one Raspberry Pi (arm64).  While the first device runs NPB and the trigger, the second runs the stairs.  Figure 3 illustrates the AAS information model that is used to generate  bridge NPB. </p>               Figure 3. The AAS information model of bridge NPB      <p>The four basic steps are as follows.    </p>"},{"location":"uc02/#step-1-download-and-load-docker-files","title":"Step 1: Download and Load Docker files","text":"<p>User can download the ROS6GBridge UC02 kit, then extract it using the command:  </p> <p>$ <code>unzip UC02_kit.zip</code></p> <p>User need to copy all arm64 files (file with arm in name) to the device  using architecture arm64. The other files are for amd64.    </p> <p>Each device needs to load its corresponding docker images. In this example,  the computer load NPB and Trigger docker images:   </p> <p>$ <code>docker load -i npb_brx_img.tar.gz</code> $ <code>docker load -i pourer_mtcp_img.tar.gz</code> </p> <p>and the Raspberry Pi loads the docker images of stairs:  </p> <p>$ <code>docker load -i stair_mtcp_img_arm.tar.gz</code> $ <code>docker load -i stair_uafx_img_arm.tar.gz</code> $ <code>docker load -i stair_ros2_img_arm.tar.gz</code> $ <code>docker load -i stair_eip_img_arm.tar.gz</code> </p>"},{"location":"uc02/#step-2-run-docker-for-stairs","title":"Step 2: Run Docker for stairs","text":"<p>Each stair may need a specific configuration to run properly. </p>"},{"location":"uc02/#a-modbus-tcp-stair","title":"a. Modbus TCP stair","text":"<p>Modbus TCP stair requires the address of NPB bridge as input. For example,  the address of NPB bridge is 192.168.56.11. Run the following command:  </p> <p>$ <code>docker run -it --net=host --rm stair_mtcp:0.2.arm /app 192.168.56.11</code> </p> <p>The expected successful output is <code>Server MODBUSTCP: port 502</code> showing that  the Modbus TCP stair is listening at port 502.   </p>"},{"location":"uc02/#b-opc-ua-fx-stair","title":"b. OPC UA FX stair","text":"<p>OPC UA FX stair requires the network interface that connect to the bridge  as input. For example, the network interface is eth0.  Run the following command:  </p> <p>$ <code>docker run -it --net=host --cap-add=NET_ADMIN --rm stair_uafx:0.2.arm /app eth0</code> </p> <p>The expected successful output is <code>Server OPC UA FX: port 4801</code> showing  that the OPC UA FX stair is listening at port 4801.   </p>"},{"location":"uc02/#c-ros2-stair","title":"c. ROS2 stair","text":"<p>ROS2 stair requires some input parameters. Run the following command:  </p> <p>$ <code>docker run -it --net=host --rm stair_ros2:0.2.arm /bin/bash -c \"export ROS_DOMAIN_ID=0 &amp;&amp; source /opt/ros/humble/setup.bash &amp;&amp; source /workspace/install/setup.bash &amp;&amp; ros2 run stair led_waterfall\"</code> </p> <p>The expected successful output is <code>Server ROS2: ROS_DOMAIN_ID=0</code>.</p>"},{"location":"uc02/#d-ethernetip-stair","title":"d. EtherNet/IP stair","text":"<p>EtherNet/IP stair requires the network interface that connect to the bridge  as input. For example, the network interface is eth0.  Run the following command:  </p> <p>$ <code>docker run -it --net=host --rm stair_eip:0.2.arm /app eth0</code> </p> <p>The expected successful output is <code>Server EtherNet/IP: port 2222</code> showing that  the EtherNet/IP stair is listening at port 2222.     </p>"},{"location":"uc02/#step-3-run-npb-docker","title":"Step 3: Run NPB Docker","text":"<p>Users need to create a configuration file application.properties which is  the input for the NPB Docker. In this example, the address of the  Raspberry Pi is 192.168.56.13 and the network interface for the connection  with it is eth0. The content of the file is as follows. </p> <p><code>app.name=npb_brxfpga</code> <code>app.version=v1.0</code> <code>app.sdn.agent.interface=eth0</code> <code>app.sdn.agent.endpoint=ws://192.168.56.11:8080</code> <code>ros2.interface=eth0</code> <code>ros2.domain.id=0</code> <code>modbustcp.interface=eth0</code> <code>modbustcp.endpoint=modbus-tcp://192.168.56.13:502</code> <code>ethernetip.interface=eth0</code> <code>ethernetip.endpoint=eip-tcp://192.168.56.13:44818</code> <code>ethernetip.data.endpoint=eip-udp://192.168.56.13:2222</code> <code>ethernetip.to.connection.point=100</code> <code>ethernetip.to.elements.range=32</code> <code>ethernetip.ot.connection.point=150</code> <code>ethernetip.ot.elements.range=32</code> <code>uafx.interface=eth0</code> <code>uafx.multicast.endpoint=udp://224.0.0.1:4801</code> </p> <p>Run NPB bridge using the following command:   </p> <p><code>cat application.properties | docker run -i --rm --net=host --cap-add=NET_ADMIN npb_brx:0.4 bash -c \"tee application.properties &amp;&amp; java -jar app.jar\"</code></p> <p>The expected successful output is <code>=========== BRx ON</code> with errors  displayed on the prompt. </p>"},{"location":"uc02/#step-4-trigger-a-stair","title":"Step 4: Trigger a stair","text":"<p>A stair can be triggered using Pourer Docker.  The trigger needs three inputs which are:  - Address of the bridge: in this example, it is 192.168.56.11. - Unit identifier of the stair: 41 (Modbus TCP), 96 (OPC UA FX), 31 (ROS2),  or 60(EtherNet/IP).  - Value: 0 (false) or 1 (true).   </p> <p>Figure 4 shows the result after triggering the stair Modbus TCP with the  following command:  </p> <p>$ <code>docker run -it --net=host --rm pourer_mtcp:0.1 /app 192.168.56.11 41 1</code> </p>               Figure 4. Output when triggering stair Modbus TCP       <p> Note: All stairs will be triggered once except stair  EtherNet/IP which will be loop.  The loop of this last stair can only be stopped by triggering it with the  value False. </p>"},{"location":"uc02/#bonus-canopen-sdo","title":"(Bonus) CANOpen SDO","text":"<p>CANOpen is a protocol for CAN bus.  Thus, it does not work with Ethernet natively.  To test a CAN bus communication, there are two solutions.  First, it requires a module to convert from one socket type to CAN bus.  For example, it is MCP2515 CAN Controller in the case of Raspberry Pi.  Second, it is possible to use a software tunnel running in the two ends  of the communication.  In both cases, users must raise the vcan interface with the following  commands:  </p> <p>$ <code>sudo modprobe vcan</code> $ <code>sudo ip link add dev vcan0 type vcan</code> $ <code>sudo ip link set vcan0 mtu 16</code> $ <code>sudo ip link set up vcan0</code> </p> <p>The following is content of tunnel.py running on the computer. </p> <pre><code>#!/usr/bin/python3\n\nimport can, socket, json\nimport threading\nimport signal\nimport os\n\ndef signal_handler(sig, frame):\n  os._exit(0)\n\nsignal.signal(signal.SIGINT,signal_handler)\n\nbus = can.interface.Bus(channel='vcan0', interface='socketcan')\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\nSRC_PORT = 8811\nSRC_ADDR = \"0.0.0.0\"\nDES_PORT = 8813\nDES_ADDR = \"192.168.56.13\"\n\ndef forward_data():\n  while True:\n    msg = bus.recv()\n    data = json.dumps({'arbitration_id': msg.arbitration_id,\n      'data': list(msg.data),'is_extended_id': msg.is_extended_id}).encode()\n    sock.sendto(data, (DES_ADDR, DES_PORT))\n\nthread = threading.Thread(target=forward_data)\nthread.start()\n\nsock.bind((SRC_ADDR, SRC_PORT))\nwhile True:\n  data, _ = sock.recvfrom(1024)\n  msg_data = json.loads(data.decode())\n  msg = can.Message(\n    arbitration_id=msg_data['arbitration_id'],\n    data=msg_data['data'],\n    is_extended_id=msg_data['is_extended_id']\n  )\n  bus.send(msg)\n</code></pre> <p> Note: For the  tunnel.py running on Raspberry Pi, it is necessary to change the values of  SRC_PORT,  DES_PORT, and  DES_ADDR. </p> <p>After establishing the CAN over Ethernet channel,  the CAN data communication is ready.  The CANOpen implemented in this test follows the simpliest CANOpen  Service Data Object  (SDO) mapping.  Figure 5 illustrates the new AAS information model of bridge NPB including  CANOpen. In detail, a new interface <code>canopen</code> and a new routing node  <code>brx_70_1_1</code> are added. </p>               Figure 5. The AAS information model of bridge NPB with CANOpen      <p>To ease the deployment, an amd64 Docker image for the bridge  and a arm64 Docker image for stair CANOpen are prepared in  ROS6GBridge UC02-b kit . Users can reuse other components to  test with these two extensions. Figure 6 shows the result when triggering  the stair CANOpen. with the following command:  </p> <p>$<code>docker run -it --net=host --rm pourer_mtcp:0.1 /app 192.168.56.11 70 1</code></p>               Figure 6. Output when triggering stair CANOpen      <p> Note: This test requires fundamentally two stairs  CANOpen and  ModbusTCP.  </p>"}]}